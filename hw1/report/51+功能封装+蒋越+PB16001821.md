# Project1-B

蒋越 PB16001821

莫定衡 PB16001716

吴昊 PB16001800

# 1. 预处理模块(PreProcessing.cpp)

## 实现原理

这里将先前写好的代码直接拷贝到文件中，并且提取出参数作为该模块的api

```c++
class PreProcessing{
    public:
        static void process(istream &infile, vector<string> &WordChain)
```

注：这里写成 static 是因为该函数是整个类共有的，而不是每个实例独有的；此外，main函数中并没有PreProcessing类的实例，因此写作静态。

接口含义：infile 代表输入流，原始的文件流赋值给infile；而WordChain是输出结果，用引用来更改它的值以起到返回结果的效果。（其实也可以设计为返回值，但是在其他模块可能要返回多个值，而返回多个值（tuple）要用到C++11的语法特性，为了避免麻烦就暂时用引用来处理了）

然后我们特地把参数infile的类型定义为istream，(原类型为ifstream)，原因是为了单元测试时候方便利用参数的多态性。即：main函数调用该模块时传入的参数是ifstream类型，而单元测试调用时传入的是istringstream类型。这样文件的读写测试就可以绕过文件系统，直接以字符串进行读写。

此外，这里还要用到我们定义的一个结构体（类）WordNode `#include "WordNode.h"`，它的定义如下：

```c++
#include <vector>

#ifndef WORDNODE_H
#define WORDNODE_H 1

class WordNode{
public:
    char prefix;
    char suffix;
    std::vector <std::string> wordlist;
    int word_count;
    int word_use;
};

#endif
```

这里用到了#ifndef WORDNODE_H宏，其作用是：

为了保证该结构体只被定义一次，而不会反复定义导致编译错误。

(#pragma once可以起到同样的效果)

## 单元测试

测试样例如下：

1. `i have a pen, i have an apple。ah, apple pen.`

   测试其常规功能，结果应当为`"have", "pen", "an", "apple", "ah" `

   测试代码如下：

   ```c++
   TEST(preprocessing_test, RemoveDuplicate){
       istringstream test_stream("i have a pen, i have an apple。ah, apple pen.");
       vector<string> vocabulary;
       PreProcessing::process(test_stream, vocabulary);
       
       vector<string> expected = { "have", "pen", "an", "apple", "ah" };
   
       ASSERT_EQ(vocabulary, expected);
   }
   ```

   

2. `i have a PeN, i hAve aN aPplE。ah, appLE pen.`

   测试其过滤大写字母的功能，结果同上，为`"have", "pen", "an", "apple", "ah" `

   测试代码类似，略

3. 空

   测试其应对异常的能力，应当抛出异常`invalid_argument("no word found in text!")`

   ```c++
   TEST(preprocessing_test, NullTest){
       istringstream null_stream;
       vector<string> vocabulary;
       try{
           PreProcessing::process(null_stream, vocabulary);
           FAIL(); // 不抛出异常，失败
       }
       catch(invalid_argument const& err){
           EXPECT_EQ(err.what(), string("no word found in text!"));
       }
       catch(...){
           FAIL(); // 抛出其他异常，失败
       }
   }
   ```

## 测试结果

经过 debug，使测试样例全部通过，代码覆盖率达到 94.2%

![image-20190402181123161](/Users/mark/Documents/ComputerScience/课程/大三下/软件工程/作业/hw1/report/pic/image-20190402181123161.png)

# 2. 命令行参数分析模块(ArgParser.cpp)

## 实现原理

将先前写在 main 函数内的代码经过整理，得到 ArgParser 类：

```c++
class ArgParser{
    public:
        static void parse(int argc, char *argv[],
        string &filename, char &head, char &tail, int &num, bool &word_flag, bool &char_flag, bool &num_flag){
```

其中 `int argc`, `char *argv[]` 是直接读取传入 main 函数的命令行参数

`string &filename `是文件名

 `char &head `和  `char &tail` 分别是规定的首尾字母

 `int &num` 是指定单词链的长度

 `bool &word_flag` 代表 `-w` 开关

 `bool &char_flag` 代表 `-c` 开关

 `bool &num_flag` 代表 `-n` 开关

这些接口本来是以变量的形式写在 main 函数里的，但是由于单元测试覆盖不到 main 函数，因此我们要尽量将 main 函数简化，最好只剩下模块调用。这样在集成测试的时候也方便 debug。

## 单元测试

测试样例如下：

1. `-w test.txt`

    -w 开关

2. `-c test.txt`

    -c 开关

3. `-w -n 114514 test.txt`

    -n 能否返回正确数字

4. `-w test.txt -h a`

   能否返回正确的头字符

5. `-w test.txt -h A`

   能否忽略头字符大小写

6. `-w test.txt -t a`

   能否返回正确的尾字符

7. `-w test.txt -t A`

   能否忽略尾字符大小写

8. `-w test.txt -h aa`

   能否抛出头字母长度异常

9. `-w test.txt -t aa`

   能否抛出尾字母长度异常

10. `-w test.txt -h 3`

    能否抛出头字母不在 ascii 范围内

11. `-w test.txt -t 3`

    能否抛出尾字母不在 ascii 范围内

12. `test.txt`

    抛出未选定工作模式异常(至少选择 -w 或 -c 的一种)

13. `test.txt -w -c`

    抛出工作模式冲突异常(无法同时 -w 和 -c)

14. `test.txt -c -n 114514`

    抛出未实现异常(并未要求实现 -c -n 同时使用的情形)

# 3. 核心模块 (Core.cpp)

## 实现原理



# 命令行参数分析：

https://github.com/tanakh/cmdline

https://blog.csdn.net/10km/article/details/50982993